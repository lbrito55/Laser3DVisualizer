(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('babylonjs'), require('babylonjs-gui'), require('babylonjs-loaders')) :
    typeof define === 'function' && define.amd ? define(['exports', 'react', 'babylonjs', 'babylonjs-gui', 'babylonjs-loaders'], factory) :
    (factory((global.reactBabylonjs = {}),global.React,global.babylonjs,global.babylonjsGui));
}(this, (function (exports,React,babylonjs,babylonjsGui) { 'use strict';

    var React__default = 'default' in React ? React['default'] : React;

    var __extends = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * Base implemention of SceneComponent.  Currently all classes are inheriting from this.
     *
     */
    var SceneComponent = /** @class */ (function (_super) {
        __extends(SceneComponent, _super);
        function SceneComponent(props, context) {
            var _this = _super.call(this, props, context) || this;
            _this.hasRendered = false;
            _this.children = [];
            _this.behaviors = [];
            _this.name = props ? props.name : undefined;
            _this.create = _this.create.bind(_this);
            _this.addBehavior = _this.addBehavior.bind(_this);
            _this.setMaterial = _this.setMaterial.bind(_this);
            _this.onRegisterChild = _this.onRegisterChild.bind(_this);
            _this.init = _this.init.bind(_this);
            _this.initComplete = _this.initComplete.bind(_this);
            return _this;
        }
        /**
         * Opportunity for component to do any setup, since this will be called before componentsCreated()
         *
         * @param child
         */
        SceneComponent.prototype.onRegisterChild = function (child) {
            this.children.push(child);
            // entire hierarchy is added here and not maintained, so it's a memory leak.  just part of proof of concept:
            this.props.componentRegistry.registeredComponents.push(child);
        };
        SceneComponent.prototype.addBehavior = function (behavior) {
            this.behaviors.push(behavior);
        };
        SceneComponent.prototype.setMaterial = function (material) {
            this.materialComponent = material;
        };
        SceneComponent.prototype.init = function (child) { };
        SceneComponent.prototype.initComplete = function (child) { };
        /**
         * Called after every prop and state change after render().
         * Not called after first render(), that is only componentDidMount
         */
        SceneComponent.prototype.componentDidUpdate = function () {
            if (this.hasRendered) {
                this.componentsCreated();
            }
        };
        SceneComponent.prototype.render = function () {
            var _this = this;
            if (this.hasRendered === false && this.props.scene) {
                this.hasRendered = true;
                var child_1 = this.create(this.props.scene);
                this.babylonObject = child_1;
                // we want to set these before onCreated() is fired.
                if (typeof this.propsHandlers !== undefined && Array.isArray(this.propsHandlers)) {
                    this.propsHandlers.forEach(function (propsHandlers) {
                        propsHandlers.handle(child_1, _this.props);
                    });
                }
                else {
                    console.error('Scene component missing propsHandlers', this);
                }
                // allow access to lifecycle phase.  ie: access propery/method exposed in props.
                if (typeof this.props.onCreated === 'function') {
                    this.props.onCreated(child_1);
                }
                // give inherited components extra life-cycle events opportunities for initialisation
                this.init(child_1);
                this.initComplete(child_1);
                // notify parent - using parent as 'this' context.
                if (this.props.container && this.props.container.onRegisterChild) {
                    this.props.container.onRegisterChild(this);
                }
                if (this.behaviors.length !== 0) {
                    this.behaviors.forEach(function (behavior) {
                        behavior.apply(child_1, _this.props.scene);
                    });
                }
                if (this.materialComponent !== undefined) {
                    // if 'child' is not abstract mesh - will apply mesh to anything:
                    this.materialComponent.apply(child_1, this.props.scene);
                }
            }
            else if (this.props.scene) {
                if (typeof this.propsHandlers !== undefined && Array.isArray(this.propsHandlers)) {
                    this.propsHandlers.forEach(function (propsHandlers) {
                        propsHandlers.handle(_this.babylonObject, _this.props);
                    });
                }
            }
            var children = React__default.Children.map(this.props.children, function (child, index) { return React__default.cloneElement(child, {
                scene: _this.props.scene,
                index: index,
                componentRegistry: _this.props.componentRegistry,
                container: _this,
                addBehavior: _this.addBehavior,
                setMaterial: _this.setMaterial
            }); });
            // we are rendering DOM.  just for testing, but may be useful for other purposes in the future. Cannot return [{children}], need JSX.Element.
            // TODO: update with React.createElement('component-name', ''');
            return React__default.createElement('span', {
                type: this.constructor.name.replace(/\$/g, '').toLowerCase(),
                title: this.props.name
            }, children);
        };
        return SceneComponent;
    }(React.Component));

    var CameraPropsHandler = /** @class */ (function () {
        function CameraPropsHandler() {
        }
        CameraPropsHandler.prototype.handle = function (camera, props) {
            var cameraProps = props;
            if (cameraProps.target) {
                // optional on FreeCamera only (not all cameras)
                if (camera instanceof babylonjs.FreeCamera) {
                    camera.setTarget(cameraProps.target);
                }
                else if (camera instanceof babylonjs.ArcRotateCamera) {
                    if (!camera.target || !camera.target.equals(cameraProps.target)) {
                        // console.log("Changing Arc Rotate target (does on init in ctor, but change detected).")
                        camera.setTarget(cameraProps.target);
                    }
                }
            }
            if (props.minZ && camera.minZ !== props.minZ) {
                camera.minZ = props.minZ;
            }
            if (props.maxZ && camera.maxZ !== props.maxZ) {
                camera.maxZ = props.maxZ;
            }
            if (props.fov && camera.fov !== props.fov) {
                camera.fov = props.fov;
            }
            // fovMode has falsey value
            if (props.fovMode !== undefined && camera.fovMode !== props.fovMode) {
                camera.fovMode = props.fovMode;
            }
        };
        return CameraPropsHandler;
    }());

    var __extends$1 = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var FreeCamera = /** @class */ (function (_super) {
        __extends$1(FreeCamera, _super);
        function FreeCamera() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        FreeCamera.prototype.componentsCreated = function () {
            /* ignored */
        };
        Object.defineProperty(FreeCamera.prototype, "camera", {
            get: function () {
                return this._camera;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FreeCamera.prototype, "noPreventDefault", {
            get: function () {
                return this.props.noPreventDefault === true;
            },
            enumerable: true,
            configurable: true
        });
        FreeCamera.prototype.create = function (scene) {
            var position;
            if (this.props.position !== undefined) {
                position = this.props.position;
            }
            else {
                position = new babylonjs.Vector3(this.props.x ? this.props.x : 0, this.props.y ? this.props.y : 0, this.props.z ? this.props.z : 0);
            }
            this._camera = new babylonjs.FreeCamera(this.props.name, position, this.props.scene, this.props.setActiveOnSceneIfNoneActive);
            return this._camera;
        };
        Object.defineProperty(FreeCamera.prototype, "propsHandlers", {
            get: function () {
                return [new CameraPropsHandler()];
            },
            enumerable: true,
            configurable: true
        });
        FreeCamera.prototype.componentWillReceiveProps = function () {
            // not implemented for Sphere
        };
        return FreeCamera;
    }(SceneComponent));

    var __extends$2 = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var ArcRotateCamera = /** @class */ (function (_super) {
        __extends$2(ArcRotateCamera, _super);
        function ArcRotateCamera() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(ArcRotateCamera.prototype, "camera", {
            get: function () {
                return this._camera;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ArcRotateCamera.prototype, "noPreventDefault", {
            get: function () {
                return this.props.noPreventDefault === true;
            },
            enumerable: true,
            configurable: true
        });
        ArcRotateCamera.prototype.componentsCreated = function () {
            /* ignored */
        };
        ArcRotateCamera.prototype.create = function (scene) {
            // defaults copied from scene.createDefaultCamera()
            var worldExtends = scene.getWorldExtends();
            var worldSize = worldExtends.max.subtract(worldExtends.min);
            var worldCenter = worldExtends.min.add(worldSize.scale(0.5));
            var radius;
            if (this.props.radius) {
                radius = this.props.radius;
            }
            else {
                radius = worldSize.length() * 1.5;
                // console.log("radius not from props:", radius)
            }
            var target;
            if (this.props.target) {
                target = this.props.target;
            }
            else {
                target = worldCenter;
            }
            this._camera = new babylonjs.ArcRotateCamera(this.props.name, this.props.alpha || -(Math.PI / 2), this.props.beta || Math.PI / 2, radius, target, scene, this.props.setActiveOnSceneIfNoneActive);
            // TODO: add a propsHandler for Arc Rotate:
            if (this.props.lowerRadiusLimit) {
                this._camera.lowerRadiusLimit = this.props.lowerRadiusLimit;
            }
            else {
                this._camera.lowerRadiusLimit = radius * 0.01;
            }
            if (this.props.wheelPrecision) {
                this._camera.wheelPrecision = this.props.wheelPrecision;
            }
            else {
                this._camera.wheelPrecision = 100 / radius;
            }
            return this._camera;
        };
        Object.defineProperty(ArcRotateCamera.prototype, "propsHandlers", {
            get: function () {
                return [new CameraPropsHandler()];
            },
            enumerable: true,
            configurable: true
        });
        return ArcRotateCamera;
    }(SceneComponent));

    /**
     * React BabylonJS
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE.txt file in the root directory of this source tree.
     */
    var __extends$3 = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __assign = (undefined && undefined.__assign) || Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    var __rest = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
                t[p[i]] = s[p[i]];
        return t;
    };
    var Scene = /** @class */ (function (_super) {
        __extends$3(Scene, _super);
        function Scene(props) {
            var _this = _super.call(this, props) || this;
            _this.firstDidUpdate = false;
            _this.onResizeWindow = function () {
                if (_this.engine) {
                    _this.engine.resize();
                }
            };
            _this.onCanvas3d = function (c) {
                if (c !== null) { // null when called from unmountComponent()
                    c.addEventListener('mouseover', _this.focus);
                    c.addEventListener('mouseout', _this.blur);
                    _this.canvas3d = c;
                }
            };
            /**
             * When canvas receives the active focus (ie: mouse over) you can add ie: (event listener to intercept keypresses)
             */
            _this.focus = function () {
                if (typeof _this.props.onSceneFocus === 'function') {
                    _this.props.onSceneFocus({
                        scene: _this.scene,
                        canvas: _this.canvas3d
                    });
                }
            };
            /**
             * When canvas loses focus (ie: mouse out).
             *
             * Ensure you remove any event handler, if you use onSceneFocus(...) and any are added there.
             */
            _this.blur = function () {
                if (typeof _this.props.onSceneBlur === 'function') {
                    // console.log('calling onBlur')
                    _this.props.onSceneBlur({
                        scene: _this.scene,
                        canvas: _this.canvas3d
                    });
                }
            };
            _this.componentRegistry = {
                meshes: [],
                lights: [],
                registeredComponents: []
            };
            _this.onRegisterChild = _this.onRegisterChild.bind(_this);
            _this.state = {
                canRender: false
            };
            return _this;
        }
        Scene.prototype.componentDidUpdate = function () {
            if (this.firstDidUpdate === false) {
                this.firstDidUpdate = true;
            }
        };
        Scene.prototype.componentDidMount = function () {
            var _this = this;
            this.engine = new babylonjs.Engine(this.canvas3d, true, this.props.engineOptions, this.props.adaptToDeviceRatio);
            if (this.props.enableOfflineSupport !== undefined) {
                this.engine.enableOfflineSupport = this.props.enableOfflineSupport;
            }
            // must set shaderRepository before creating engine?  need to pass in as props.
            if (this.props.shadersRepository !== undefined) {
                babylonjs.Engine.ShadersRepository = this.props.shadersRepository;
            }
            var scene = new babylonjs.Scene(this.engine);
            this.scene = scene;
            if (this.props.debug === true) {
                this.scene.debugLayer.show();
            }
            //scene.executeWhenReady(() => {
            //});
            if (typeof this.props.onSceneMount === 'function') {
                this.props.onSceneMount({
                    scene: scene,
                    canvas: this.canvas3d
                });
                // TODO: console.error if canvas is not attached. runRenderLoop() is expected to be part of onSceneMount().
            }
            else {
                if (typeof this.props.createCamera === 'function') {
                    var camera = this.props.createCamera({
                        scene: scene,
                        canvas: this.canvas3d
                    });
                }
                else {
                    console.warn('no onSceneMount() or createCamera() defined.  Require camera declaration.');
                }
                var engine_1 = this.engine;
                engine_1.runRenderLoop(function () {
                    if (engine_1.scenes.length === 0) {
                        return;
                    }
                    if (_this.canvas3d.width !== _this.canvas3d.clientWidth || _this.canvas3d.height !== _this.canvas3d.clientWidth) {
                        engine_1.resize();
                    }
                    var scene = engine_1.scenes[0];
                    if (scene.activeCamera || scene.activeCameras.length > 0) {
                        scene.render();
                    }
                });
            }
            // TODO: Add other PointerEventTypes and keyDown.
            scene.onPointerObservable.add(function (evt) {
                if (evt && evt.pickInfo && evt.pickInfo.hit && evt.pickInfo.pickedMesh) {
                    var mesh = evt.pickInfo.pickedMesh;
                    if (typeof _this.props.onMeshPicked === 'function') {
                        _this.props.onMeshPicked(mesh, scene);
                    }
                }
            }, babylonjs.PointerEventTypes.POINTERDOWN);
            this.forceUpdate(function () {
            });
            // nested callbacks are needed for how React batches updates and canvas size can change.
            setTimeout(function () {
                window.requestAnimationFrame(function () {
                    _this.engine.resize();
                });
            }, 0);
            this.setState({ canRender: true });
            // Resize the babylon engine when the window is resized
            window.addEventListener('resize', this.onResizeWindow);
        };
        Scene.prototype.componentWillUnmount = function () {
            // unregister from window and canvas events
            window.removeEventListener('resize', this.onResizeWindow);
            if (this.canvas3d) {
                this.canvas3d.removeEventListener('mouseover', this.focus);
                this.canvas3d.removeEventListener('mouseout', this.blur);
            }
        };
        Scene.prototype.onRegisterChild = function (child) {
            if (child instanceof FreeCamera || child instanceof ArcRotateCamera) {
                console.log('react-babylonjs: Camera registered.  Attaching to canvas.');
                // TODO: ensure this is only done once - and not using 'instanceof', which is brittle...
                child.camera.attachControl(this.canvas3d, child.noPreventDefault);
            }
            this.componentRegistry.registeredComponents.push(child);
        };
        // NOTE: canvas width is in pixels, use style to set % using ID, if needed.
        Scene.prototype.render = function () {
            var _this = this;
            if (this.state.canRender === false && (this.props.noSSR !== undefined && this.props.noSSR !== false)) {
                if (typeof this.props.noSSR === 'boolean') {
                    return null;
                }
                return this.props.noSSR;
            }
            var _a = this.props, touchActionNone = _a.touchActionNone, id = _a.id, width = _a.width, height = _a.height, rest = __rest(_a, ["touchActionNone", "id", "width", "height"]);
            var opts = {};
            if (touchActionNone !== false) {
                opts['touch-action'] = 'none';
            }
            if (width !== undefined && height !== undefined) {
                opts.width = width;
                opts.height = height;
            }
            if (id) {
                opts.id = id;
            }
            var children = React__default.Children.map(this.props.children, function (child, index) {
                if (child === null) {
                    return null;
                }
                return React__default.cloneElement(child, {
                    scene: _this.scene,
                    index: index,
                    container: _this,
                    componentRegistry: _this.componentRegistry,
                    registerChild: _this.onRegisterChild
                });
            });
            // TODO: passing height/width/style explicitly now will not be predictable.
            return (React__default.createElement("canvas", __assign({}, opts, { ref: this.onCanvas3d }), children));
        };
        return Scene;
    }(React.Component));

    var LightPropsHandler = /** @class */ (function () {
        function LightPropsHandler() {
        }
        LightPropsHandler.prototype.handle = function (target, props) {
            if (props.intensity) {
                target.intensity = props.intensity;
            }
            if (props.position) {
                var lightTarget = target;
                if (!lightTarget.position || !lightTarget.position.equals(props.position)) {
                    // console.log(`moving light ${target.name} to:`, props.position);
                    lightTarget.position.copyFrom(props.position);
                }
            }
        };
        return LightPropsHandler;
    }());

    var __extends$4 = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var HemisphericLight = /** @class */ (function (_super) {
        __extends$4(HemisphericLight, _super);
        function HemisphericLight() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        HemisphericLight.prototype.componentsCreated = function () {
            /* ignored */
        };
        HemisphericLight.prototype.create = function (scene) {
            var direction;
            if (this.props.direction !== undefined) {
                direction = this.props.direction;
            }
            else {
                direction = new babylonjs.Vector3(this.props.x ? this.props.x : 0, this.props.y ? this.props.y : 0, this.props.z ? this.props.z : 0);
            }
            this.light = new babylonjs.HemisphericLight(this.props.name, direction, scene);
            return this.light;
        };
        Object.defineProperty(HemisphericLight.prototype, "propsHandlers", {
            get: function () {
                return [new LightPropsHandler()];
            },
            enumerable: true,
            configurable: true
        });
        return HemisphericLight;
    }(SceneComponent));

    var __extends$5 = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var DirectionalLight = /** @class */ (function (_super) {
        __extends$5(DirectionalLight, _super);
        function DirectionalLight() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(DirectionalLight.prototype, "light", {
            get: function () {
                return this._light;
            },
            enumerable: true,
            configurable: true
        });
        DirectionalLight.prototype.create = function (scene) {
            var direction;
            if (this.props.direction !== undefined) {
                direction = this.props.direction;
            }
            else {
                direction = new babylonjs.Vector3(this.props.x ? this.props.x : 0, this.props.y ? this.props.y : 0, this.props.z ? this.props.z : 0);
            }
            this._light = new babylonjs.DirectionalLight(this.props.name, direction, scene);
            return this._light;
        };
        DirectionalLight.prototype.componentsCreated = function () {
            /* ignore */
        };
        Object.defineProperty(DirectionalLight.prototype, "propsHandlers", {
            get: function () {
                return [new LightPropsHandler()];
            },
            enumerable: true,
            configurable: true
        });
        return DirectionalLight;
    }(SceneComponent));

    var __extends$6 = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var ShadowGenerator = /** @class */ (function (_super) {
        __extends$6(ShadowGenerator, _super);
        function ShadowGenerator() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ShadowGenerator.prototype.create = function (scene) {
            var container = this.props.container;
            if (container instanceof DirectionalLight) {
                // console.log("Creating a shadow generater for directional light:", container.light)
                if (container.light) {
                    this.shadowGenerator = new babylonjs.ShadowGenerator(this.props.mapSize, container.light);
                }
            }
            else {
                console.error("ShadowGenerator only setup to work with DirectionLight as direct parent.");
            }
            return this.shadowGenerator;
        };
        ShadowGenerator.prototype.componentsCreated = function () {
            var _this = this;
            // need a listener for models, which will not have been loaded.
            var registeredMeshes = this.props.componentRegistry.meshes;
            if (!this.props.shadowCasters) {
                console.warn("no shadow casters = no shadows");
                return;
            }
            // props cannot dynamically be set, although that wouldn't be too much to add!
            var shadowCasters = this.props.shadowCasters.slice(0);
            // TODO: also need a listener for models or if we want to add a predicate:
            this.props.scene.onNewMeshAddedObservable.add(function (mesh) {
                if (shadowCasters.indexOf(mesh.name) >= 0) {
                    _this.shadowGenerator.addShadowCaster(mesh);
                    shadowCasters = shadowCasters.filter(function (name) { return name !== mesh.name; });
                }
            });
            registeredMeshes.forEach(function (mesh) {
                if (shadowCasters.indexOf(mesh.name) >= 0) {
                    _this.shadowGenerator.addShadowCaster(mesh);
                    shadowCasters = shadowCasters.filter(function (name) { return name !== mesh.name; });
                }
            });
        };
        Object.defineProperty(ShadowGenerator.prototype, "propsHandlers", {
            get: function () {
                return [];
            },
            enumerable: true,
            configurable: true
        });
        return ShadowGenerator;
    }(SceneComponent));

    var MeshPropsHandler = /** @class */ (function () {
        function MeshPropsHandler() {
            this.hasRunOnce = false;
        }
        MeshPropsHandler.prototype.handle = function (target, props) {
            if (props.position && target) {
                if (!target.position || !target.position.equals(props.position)) {
                    // console.log(`moving ${target.name} to:`, props.position)
                    target.position.copyFrom(props.position);
                }
            }
            // NOTE: no accounting for rotationQuaternion, so this will have no effect when rotationQuaternion is set, obviously.
            if (props.rotation && target) {
                if (!target.rotation || !target.rotation.equals(props.rotation)) {
                    // console.log(`rotating ${target.name} to:`, props.rotation)
                    target.rotation.copyFrom(props.rotation);
                }
            }
            if (props.showBoundingBox !== undefined && target) {
                if (target.showBoundingBox !== props.showBoundingBox) {
                    // console.log(`${props.showBoundingBox === true ? "showing" : "hiding"} bounding box on '${target.name}'`)
                    target.showBoundingBox = props.showBoundingBox;
                }
            }
            if (props.renderingGroupId !== undefined) {
                target.renderingGroupId = props.renderingGroupId;
            }
            if (props.scaling && target && !target.scaling.equals(props.scaling)) {
                target.scaling.copyFrom(props.scaling);
            }
            if (props.visibility !== undefined && target) {
                target.visibility = props.visibility;
            }
            if (this.hasRunOnce === false &&
                target &&
                (props.pivotMatrix !== undefined || props.preTransformMatrix !== undefined)) {
                this.hasRunOnce = true;
                if (props.pivotMatrix) {
                    target.setPivotMatrix(props.pivotMatrix);
                }
                // order is important, as this calls setPivotMatrix(matrix, false) and doesn't set the inverse matrix:
                if (props.preTransformMatrix) {
                    target.setPreTransformMatrix(props.preTransformMatrix);
                }
            }
        };
        return MeshPropsHandler;
    }());

    var __extends$7 = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __assign$1 = (undefined && undefined.__assign) || Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    var __rest$1 = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
                t[p[i]] = s[p[i]];
        return t;
    };
    var Box = /** @class */ (function (_super) {
        __extends$7(Box, _super);
        function Box(props) {
            var _this = _super.call(this, props) || this;
            var scene = props.scene, name = props.name, onCreated = props.onCreated, rest = __rest$1(props, ["scene", "name", "onCreated"]);
            _this.options = __assign$1({}, rest);
            return _this;
        }
        Box.prototype.create = function (scene) {
            this.box = babylonjs.MeshBuilder.CreateBox(this.props.name ? this.props.name : "", this.options, scene);
            // TODO: remove on unmount
            this.props.componentRegistry.meshes.push(this.box);
            return this.box;
        };
        Box.prototype.componentsCreated = function () {
            /* ignore */
        };
        Box.prototype.componentWillUnmount = function () {
            this.box.dispose();
        };
        Object.defineProperty(Box.prototype, "propsHandlers", {
            get: function () {
                return [new MeshPropsHandler()];
            },
            enumerable: true,
            configurable: true
        });
        return Box;
    }(SceneComponent));

    var __extends$8 = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __assign$2 = (undefined && undefined.__assign) || Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    var __rest$2 = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
                t[p[i]] = s[p[i]];
        return t;
    };
    var Sphere = /** @class */ (function (_super) {
        __extends$8(Sphere, _super);
        function Sphere(props) {
            var _this = _super.call(this, props) || this;
            var scene = props.scene, rest = __rest$2(props, ["scene"]);
            _this.options = __assign$2({}, rest);
            return _this;
        }
        Sphere.prototype.create = function (scene) {
            this.sphere = babylonjs.MeshBuilder.CreateSphere(this.props.name, this.options, scene);
            // TODO: remove on unmount
            this.props.componentRegistry.meshes.push(this.sphere);
            return this.sphere;
        };
        Sphere.prototype.componentsCreated = function () {
            /* ignore */
        };
        Object.defineProperty(Sphere.prototype, "propsHandlers", {
            get: function () {
                return [new MeshPropsHandler()];
            },
            enumerable: true,
            configurable: true
        });
        return Sphere;
    }(SceneComponent));

    var __extends$9 = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var Box$1 = /** @class */ (function (_super) {
        __extends$9(Box, _super);
        function Box(props) {
            var _this = _super.call(this, props) || this;
            var radius = props.radius, flat = props.flat, subdivisions = props.subdivisions;
            _this.options = { radius: radius, flat: flat, subdivisions: subdivisions };
            return _this;
        }
        Box.prototype.create = function (scene) {
            this.icoSphere = babylonjs.MeshBuilder.CreateIcoSphere(this.props.name, this.options, scene);
            // TODO: remove on unmount
            this.props.componentRegistry.meshes.push(this.icoSphere);
            return this.icoSphere;
        };
        Box.prototype.componentsCreated = function () {
            /* ignore */
        };
        Box.prototype.componentWillUnmount = function () {
            this.icoSphere.dispose();
        };
        Object.defineProperty(Box.prototype, "propsHandlers", {
            get: function () {
                return [new MeshPropsHandler()];
            },
            enumerable: true,
            configurable: true
        });
        return Box;
    }(SceneComponent));

    var __extends$a = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __assign$3 = (undefined && undefined.__assign) || Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    var __rest$3 = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
                t[p[i]] = s[p[i]];
        return t;
    };
    var Plane = /** @class */ (function (_super) {
        __extends$a(Plane, _super);
        function Plane(props) {
            var _this = _super.call(this, props) || this;
            var scene = props.scene, name = props.name, rest = __rest$3(props, ["scene", "name"]);
            _this.options = __assign$3({}, rest);
            return _this;
        }
        Plane.prototype.componentWillReceiveProps = function () {
            // not implemented for Plane
        };
        Plane.prototype.create = function (scene) {
            this.plane = babylonjs.MeshBuilder.CreatePlane(this.props.name, this.options, scene);
            // TODO: remove on unmount
            this.props.componentRegistry.meshes.push(this.plane);
            return this.plane;
        };
        Plane.prototype.componentsCreated = function () {
            /* ignore */
        };
        Object.defineProperty(Plane.prototype, "propsHandlers", {
            get: function () {
                return [new MeshPropsHandler()];
            },
            enumerable: true,
            configurable: true
        });
        return Plane;
    }(SceneComponent));

    var __extends$b = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __assign$4 = (undefined && undefined.__assign) || Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    var __rest$4 = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
                t[p[i]] = s[p[i]];
        return t;
    };
    var Ground = /** @class */ (function (_super) {
        __extends$b(Ground, _super);
        function Ground(props) {
            var _this = _super.call(this, props) || this;
            var scene = props.scene, name = props.name, rest = __rest$4(props, ["scene", "name"]);
            _this.options = __assign$4({}, rest);
            return _this;
        }
        Ground.prototype.componentWillReceiveProps = function () {
            // not implemented for Ground
        };
        Ground.prototype.create = function (scene) {
            this.ground = babylonjs.MeshBuilder.CreateGround(this.props.name, this.options, scene);
            // TODO: remove on unmount
            this.props.componentRegistry.meshes.push(this.ground);
            return this.ground;
        };
        Ground.prototype.componentsCreated = function () {
            /* ignore */
        };
        Object.defineProperty(Ground.prototype, "propsHandlers", {
            get: function () {
                return [new MeshPropsHandler()];
            },
            enumerable: true,
            configurable: true
        });
        return Ground;
    }(SceneComponent));

    var __extends$c = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var GUI3DSceneComponent = /** @class */ (function (_super) {
        __extends$c(GUI3DSceneComponent, _super);
        function GUI3DSceneComponent(props, context) {
            var _this = _super.call(this, props, context) || this;
            _this.added = false;
            _this.addControl = _this.addControl.bind(_this);
            _this.removeControl = _this.removeControl.bind(_this);
            return _this;
        }
        GUI3DSceneComponent.prototype.init = function (child) {
            // only GUISceneComponent inherite
            if (typeof this.props.container.addControl === "function") {
                this.added = true;
                this.props.container.addControl(child);
            }
        };
        return GUI3DSceneComponent;
    }(SceneComponent));

    var __extends$d = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * To begin with 3D GUI, you need to instantiate a GUI3DManager which will be responsible for connecting all controls together:
     *
     * The manager only requires the scene to work on. Once instantiated, the manager will create an utility layer which is a specific child scene which will host all meshes used to render the controls.
     * This way, your main scene won't get poluated by the utility meshes.
     * You can reach the utility layer with manager.utilityLayer.
     *
     * Once you have a manager, you can start adding controls with manager.addControl(control). All controls will be added to the manager.rootContainer container.
     */
    var GUI3DManager = /** @class */ (function (_super) {
        __extends$d(GUI3DManager, _super);
        function GUI3DManager() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        GUI3DManager.prototype.create = function (scene) {
            this.gui3dManager = new babylonjsGui.GUI3DManager(scene);
            return this.gui3dManager;
        };
        GUI3DManager.prototype.addControl = function (control) {
            this.gui3dManager.addControl(control);
        };
        GUI3DManager.prototype.removeControl = function (control) {
            this.gui3dManager.removeControl(control);
        };
        GUI3DManager.prototype.componentsCreated = function () {
            // not used
        };
        Object.defineProperty(GUI3DManager.prototype, "propsHandlers", {
            get: function () {
                return [];
            },
            enumerable: true,
            configurable: true
        });
        return GUI3DManager;
    }(GUI3DSceneComponent));

    var __extends$e = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var CylinderPanelPropsHandler = /** @class */ (function () {
        function CylinderPanelPropsHandler() {
        }
        CylinderPanelPropsHandler.prototype.handle = function (target, props) {
            if (props.columns && target) {
                if (!target.columns || target.columns !== props.columns) {
                    target.columns = props.columns;
                }
            }
            if (props.rows && target) {
                if (!target.rows || target.rows !== props.rows) {
                    target.rows = props.rows;
                }
            }
            // TODO: radius, orientation, position, margin
        };
        return CylinderPanelPropsHandler;
    }());
    /**
     *
     */
    var CylinderPanel = /** @class */ (function (_super) {
        __extends$e(CylinderPanel, _super);
        function CylinderPanel() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        CylinderPanel.prototype.addControl = function (control) {
            // console.log("adding control to cylinder panel:", control)
            this.cylinderPanel.addControl(control);
        };
        CylinderPanel.prototype.removeControl = function (control) {
            // console.log("removing control to cylinder panel:", control)
            this.cylinderPanel.removeControl(control);
        };
        CylinderPanel.prototype.componentsCreated = function () {
            // not used
        };
        CylinderPanel.prototype.componentWillUnmount = function () {
            this.props.container.removeControl(this.cylinderPanel);
        };
        CylinderPanel.prototype.create = function (scene) {
            this.cylinderPanel = new babylonjsGui.CylinderPanel();
            if (this.props.margin) {
                // console.log("setting cylinder panel margin")
                this.cylinderPanel.margin = this.props.margin;
            }
            if (this.props.orientation) {
                this.cylinderPanel.orientation = this.props.orientation;
            }
            if (this.props.radius) {
                this.cylinderPanel.radius = this.props.radius;
            }
            return this.cylinderPanel;
        };
        /**
         * We don't want to linkToTransformNode(anchor) until after the panel has been added to 3DManager.
         *
         * From docs: When linking a control to a transform node, please make sure that the control was first added to a container or to the root manager.
         *
         * @param cylinderPanel panel to further initialise
         */
        CylinderPanel.prototype.initComplete = function (cylinderPanel) {
            // just for now - will be adding Anchor as a dynamic element:
            var anchor = new babylonjs.TransformNode("");
            if (this.props.position) {
                anchor.position = this.props.position;
            }
            else {
                console.log("targeting 1.5 meters in front of camera as default position");
                anchor.position.z = -1.5;
            }
            cylinderPanel.linkToTransformNode(anchor);
        };
        Object.defineProperty(CylinderPanel.prototype, "propsHandlers", {
            get: function () {
                return [new CylinderPanelPropsHandler()];
            },
            enumerable: true,
            configurable: true
        });
        return CylinderPanel;
    }(GUI3DSceneComponent));

    var __extends$f = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     *
     */
    var HolographicButton = /** @class */ (function (_super) {
        __extends$f(HolographicButton, _super);
        function HolographicButton() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        HolographicButton.prototype.addControl = function (control) {
            console.log("not implemented adding controls to holographic button");
        };
        HolographicButton.prototype.removeControl = function (control) {
            throw new Error("Method not implemented.");
        };
        HolographicButton.prototype.componentsCreated = function () {
            // not used
        };
        HolographicButton.prototype.componentWillUnmount = function () {
            this.props.container.removeControl(this.holographicButton);
        };
        HolographicButton.prototype.create = function (scene) {
            var _this = this;
            this.holographicButton = new babylonjsGui.HolographicButton(this.props.name);
            this.holographicButton.text = this.props.text;
            if (this.props.imageUrl) {
                this.holographicButton.imageUrl = this.props.imageUrl;
            }
            if (this.props.onClick) {
                // onPointerClickObservable has some issues...
                this.holographicButton.onPointerDownObservable.add(function () {
                    _this.props.onClick(_this.holographicButton);
                });
            }
            return this.holographicButton;
        };
        Object.defineProperty(HolographicButton.prototype, "propsHandlers", {
            get: function () {
                return [];
            },
            enumerable: true,
            configurable: true
        });
        return HolographicButton;
    }(GUI3DSceneComponent));

    var __extends$g = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     *
     */
    var Button3D = /** @class */ (function (_super) {
        __extends$g(Button3D, _super);
        function Button3D() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Button3D.prototype.addControl = function (control) {
            console.warn("not implemented adding controls to Button3D (it uses content)");
        };
        Button3D.prototype.removeControl = function (control) {
            throw new Error("Method not implemented.");
        };
        Button3D.prototype.componentsCreated = function () {
            // not used
        };
        Button3D.prototype.componentWillUnmount = function () {
            this.props.container.removeControl(this.button3D);
        };
        /**
         * The mesh that we would like to set properties on, is created only once the
         *
         * @param button3D button to further initialise
         */
        Button3D.prototype.initComplete = function (button3D) {
            var _this = this;
            if (this.props.diffuseColor) {
                if (button3D.mesh) {
                    var material = button3D.mesh.material;
                    if (material) {
                        // console.log("applying diffuse:", this.props.diffuseColor)
                        material.diffuseColor = this.props.diffuseColor;
                    }
                }
            }
            if (this.props.hoverEmmissiveColor) {
                if (button3D.mesh) {
                    var material_1 = button3D.mesh.material;
                    button3D.pointerEnterAnimation = function () {
                        material_1.emissiveColor = _this.props.hoverEmmissiveColor;
                    };
                    button3D.pointerOutAnimation = function () {
                        material_1.emissiveColor = babylonjs.Color3.Black();
                    };
                }
            }
        };
        Button3D.prototype.create = function (scene) {
            var _this = this;
            this.button3D = new babylonjsGui.Button3D(this.props.name);
            // console.log("created button", this.props.name)
            var text = undefined;
            var image = undefined;
            if (this.props.imageUrl) {
                image = new babylonjsGui.Image(this.props.name + "-image", this.props.imageUrl);
            }
            if (this.props.text) {
                text = new babylonjsGui.TextBlock();
                text.text = this.props.text;
                if (this.props.fontColor) {
                    text.color = this.props.fontColor.toHexString();
                }
                else {
                    text.color = "white"; // default in BabylonJS
                }
                if (this.props.fontSize) {
                    text.fontSize = this.props.fontSize;
                }
                else {
                    text.fontSize = 24; // default in BabylonJS
                }
            }
            if (text && image) {
                var stackPanel = new babylonjsGui.StackPanel();
                stackPanel.background = "#CCCCCC";
                stackPanel.isVertical = true;
                stackPanel.height = "256px"; // should be = 512 / contentScaleRatio
                image.paddingTop = "10px";
                if (this.props.imageWidth) {
                    image.width = this.props.imageWidth;
                }
                else {
                    image.width = "180px";
                }
                if (this.props.imageHeight) {
                    image.height = this.props.imageHeight;
                }
                else {
                    image.height = "180px";
                }
                image.paddingBottom = "10px";
                stackPanel.addControl(image);
                text.height = "56px"; // was 30px in Holographic button, but wanted bigger text.
                stackPanel.addControl(text);
                this.button3D.content = stackPanel;
            }
            else if (text) {
                this.button3D.content = text;
            }
            else if (image) {
                // Scale the image to fill the container but maintain aspect ratio. Default is STRETCH_FILL
                image.stretch = babylonjsGui.Image.STRETCH_UNIFORM;
                image.horizontalAlignment = babylonjsGui.Control.HORIZONTAL_ALIGNMENT_CENTER;
                this.button3D.contentScaleRatio = 1;
                this.button3D.content = image;
            }
            if (this.props.onClick) {
                // onPointerClickObservable has some issues...
                this.button3D.onPointerDownObservable.add(function () {
                    _this.props.onClick(_this.button3D);
                });
            }
            return this.button3D;
        };
        Object.defineProperty(Button3D.prototype, "propsHandlers", {
            get: function () {
                return [];
            },
            enumerable: true,
            configurable: true
        });
        return Button3D;
    }(GUI3DSceneComponent));

    var __extends$h = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var GUI2DSceneComponent = /** @class */ (function (_super) {
        __extends$h(GUI2DSceneComponent, _super);
        function GUI2DSceneComponent(props, context) {
            var _this = _super.call(this, props, context) || this;
            _this.added = false;
            _this.addControl = _this.addControl.bind(_this);
            _this.removeControl = _this.removeControl.bind(_this);
            return _this;
        }
        GUI2DSceneComponent.prototype.init = function (child) {
            var _this = this;
            // best to have the control have properties set before adding.
            this.propsHandlers.forEach(function (propsHandlers) {
                propsHandlers.handle(child, _this.props);
            });
            if (typeof this.props.container.addControl === "function") {
                this.added = true;
                this.props.container.addControl(child);
            }
        };
        GUI2DSceneComponent.prototype.componentWillUnmount = function () {
            if (typeof this.props.container.removeControl === "function") {
                this.props.container.removeControl(this.babylonObject);
            }
        };
        return GUI2DSceneComponent;
    }(SceneComponent));

    var ControlPropsHandler = /** @class */ (function () {
        function ControlPropsHandler() {
        }
        ControlPropsHandler.prototype.handle = function (target, props) {
            if (props.paddingLeft && target) {
                if (!target.paddingLeft || target.paddingLeft !== props.paddingLeft) {
                    // console.log(`setting paddingLeft on ${target.name} to:`, props.paddingLeft)
                    target.paddingLeft = props.paddingLeft;
                }
            }
            if (props.paddingRight && target) {
                if (!target.paddingRight || target.paddingRight !== props.paddingRight) {
                    // console.log(`setting paddingRight on ${target.name} to:`, props.paddingRight)
                    target.paddingRight = props.paddingRight;
                }
            }
            if (props.paddingTop && target) {
                if (!target.paddingTop || target.paddingTop !== props.paddingTop) {
                    // console.log(`setting paddingTop on ${target.name} to:`, props.paddingTop)
                    target.paddingTop = props.paddingTop;
                }
            }
            if (props.paddingBottom && target) {
                if (!target.paddingBottom || target.paddingBottom !== props.paddingBottom) {
                    // console.log(`setting background on ${target.name} to:`, props.paddingBottom)
                    target.paddingBottom = props.paddingBottom;
                }
            }
            if (target) {
                if (props.height) {
                    if (!target.height || target.height !== props.height) {
                        // console.log(`setting height on ${target.name} to:`, props.height)
                        target.height = props.height;
                    }
                }
                else {
                    target.height = "100%";
                }
            }
            if (target) {
                if (props.width) {
                    if (!target.width || target.width !== props.width) {
                        // console.log(`setting width on ${target.name} to:`, props.width)
                        target.width = props.width;
                    }
                }
                else {
                    target.width = "100%";
                }
            }
            if (target) {
                // 0 is falsey
                if (props.horizontalAlignment !== undefined) {
                    if (target.horizontalAlignment !== props.horizontalAlignment) {
                        // console.log(`setting horizontalAlignment on ${target.name} to:`, props.horizontalAlignment)
                        target.horizontalAlignment = props.horizontalAlignment;
                    }
                }
                // 0 is falsey
                if (props.verticalAlignment !== undefined) {
                    if (target.verticalAlignment !== props.verticalAlignment) {
                        // console.log(`setting verticalAlignment on ${target.name} to:`, props.verticalAlignment)
                        target.verticalAlignment = props.verticalAlignment;
                    }
                }
            }
            if (props.scaleX !== undefined && target) {
                if (target.scaleX !== undefined || target.scaleX !== props.scaleX) {
                    // console.log(`setting paddingLeft on ${target.name} to:`, props.paddingLeft)
                    target.scaleX = props.scaleX;
                }
            }
            if (props.scaleY !== undefined && target) {
                if (target.scaleY !== undefined || target.scaleY !== props.scaleY) {
                    // console.log(`setting paddingLeft on ${target.name} to:`, props.paddingLeft)
                    target.scaleY = props.scaleY;
                }
            }
        };
        return ControlPropsHandler;
    }());

    var __extends$i = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var TextPropsHandler = /** @class */ (function () {
        function TextPropsHandler() {
        }
        TextPropsHandler.prototype.handle = function (target, props) {
            if (props.text && target) {
                if (!target.text || target.text !== props.text) {
                    target.text = props.text;
                }
            }
        };
        return TextPropsHandler;
    }());
    /**
     * Cannot be attached directly to a 3D panel.
     */
    var Text = /** @class */ (function (_super) {
        __extends$i(Text, _super);
        function Text() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Text.prototype.componentsCreated = function () {
            // not used
        };
        Text.prototype.addControl = function (control) {
            throw new Error("Method not implemented.");
        };
        Text.prototype.removeControl = function (control) {
            throw new Error("Method not implemented.");
        };
        Text.prototype.create = function (scene) {
            // allow newline char, but should force users to use text={'line1.\nline2.'} to override.
            var text = this.props.text.replace(/(\\n)+/g, "\n");
            this.textBlock = new babylonjsGui.TextBlock(this.props.name, text);
            // this belongs in control props handler
            if (this.props.color) {
                this.textBlock.color = this.props.color;
            }
            // TODO: move all of these to props handler
            if (this.props.fontSize) {
                this.textBlock.fontSize = this.props.fontSize;
            }
            if (this.props.fontStyle) {
                this.textBlock.fontStyle = this.props.fontStyle;
            }
            if (this.props.fontFamily) {
                this.textBlock.fontFamily = this.props.fontFamily;
            }
            if (this.props.textWrapping !== undefined) {
                this.textBlock.textWrapping = this.props.textWrapping;
            }
            // 0 is falsey
            if (this.props.textHorizontalAlignment !== undefined) {
                this.textBlock.textHorizontalAlignment = this.props.textHorizontalAlignment;
            }
            // 0 is falsey
            if (this.props.textVerticalAlignment !== undefined) {
                this.textBlock.textVerticalAlignment = this.props.textVerticalAlignment;
            }
            return this.textBlock;
        };
        Object.defineProperty(Text.prototype, "propsHandlers", {
            get: function () {
                return [new ControlPropsHandler(), new TextPropsHandler()];
            },
            enumerable: true,
            configurable: true
        });
        return Text;
    }(GUI2DSceneComponent));

    var __extends$j = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var InputTextPropsHandler = /** @class */ (function () {
        function InputTextPropsHandler() {
        }
        InputTextPropsHandler.prototype.handle = function (target, props) {
            if (props.text && target) {
                if (!target.text || target.text !== props.text) {
                    target.text = props.text;
                }
            }
        };
        return InputTextPropsHandler;
    }());
    /**
     * Cannot be attached directly to a 3D panel.
     */
    var InputText = /** @class */ (function (_super) {
        __extends$j(InputText, _super);
        function InputText() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        InputText.prototype.componentsCreated = function () {
            // not used
        };
        InputText.prototype.addControl = function (control) {
            throw new Error("Method not implemented.");
        };
        InputText.prototype.removeControl = function (control) {
            throw new Error("Method not implemented.");
        };
        InputText.prototype.create = function (scene) {
            this.inputText = new babylonjsGui.InputText(this.props.name, this.props.text);
            if (this.props.onTextChanged && typeof this.props.onTextChanged == "function") {
                this.inputText.onTextChangedObservable.add(this.props.onTextChanged);
            }
            // this belongs in control props handler
            if (this.props.color) {
                this.inputText.color = this.props.color;
            }
            // TODO: move all of these to props handler
            if (this.props.fontSize) {
                this.inputText.fontSize = this.props.fontSize;
            }
            if (this.props.fontStyle) {
                this.inputText.fontStyle = this.props.fontStyle;
            }
            if (this.props.fontFamily) {
                this.inputText.fontFamily = this.props.fontFamily;
            }
            return this.inputText;
        };
        Object.defineProperty(InputText.prototype, "propsHandlers", {
            get: function () {
                return [new ControlPropsHandler(), new InputTextPropsHandler()];
            },
            enumerable: true,
            configurable: true
        });
        return InputText;
    }(GUI2DSceneComponent));

    var ContainerPropsHandler = /** @class */ (function () {
        function ContainerPropsHandler() {
        }
        ContainerPropsHandler.prototype.handle = function (target, props) {
            if (props.background && target) {
                if (!target.background || target.background !== props.background) {
                    // console.log(`setting background on ${target.name} to:`, props.background)
                    target.background = props.background;
                }
            }
            if (props.color && target) {
                if (!target.color || target.color !== props.color) {
                    // console.log(`setting background on ${target.name} to:`, props.color)
                    target.color = props.color;
                }
            }
        };
        return ContainerPropsHandler;
    }());

    var __extends$k = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var StackPanel = /** @class */ (function (_super) {
        __extends$k(StackPanel, _super);
        function StackPanel() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        StackPanel.prototype.create = function (scene) {
            this.stackPanel = new babylonjsGui.StackPanel(this.props.name);
            if (this.props.isVertical !== undefined) {
                this.stackPanel.isVertical = this.props.isVertical;
            }
            return this.stackPanel;
        };
        StackPanel.prototype.addControl = function (control) {
            this.stackPanel.addControl(control);
        };
        StackPanel.prototype.removeControl = function (control) {
            this.stackPanel.removeControl(control);
        };
        StackPanel.prototype.componentsCreated = function () {
            /* ignore */
        };
        Object.defineProperty(StackPanel.prototype, "propsHandlers", {
            get: function () {
                return [new ContainerPropsHandler(), new ControlPropsHandler()];
            },
            enumerable: true,
            configurable: true
        });
        return StackPanel;
    }(GUI2DSceneComponent));

    var __extends$l = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var RectanglePropsHandler = /** @class */ (function () {
        function RectanglePropsHandler() {
        }
        RectanglePropsHandler.prototype.handle = function (target, props) {
            if (props.thickness && target) {
                if (!target.thickness || target.thickness !== props.thickness) {
                    // console.log(`setting '${target.name}' thickness to:`, props.thickness)
                    target.thickness = props.thickness;
                }
            }
            if (props.cornerRadius && target) {
                if (!target.cornerRadius || target.cornerRadius !== props.cornerRadius) {
                    // console.log(`setting '${target.name}' cornerRadius to:`, props.cornerRadius)
                    target.cornerRadius = props.cornerRadius;
                }
            }
        };
        return RectanglePropsHandler;
    }());
    var Rectangle = /** @class */ (function (_super) {
        __extends$l(Rectangle, _super);
        function Rectangle() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Rectangle.prototype.addControl = function (control) {
            this.rectangle.addControl(control);
        };
        Rectangle.prototype.removeControl = function (control) {
            this.rectangle.removeControl(control);
        };
        Rectangle.prototype.create = function (scene) {
            this.rectangle = new babylonjsGui.Rectangle(this.props.name);
            return this.rectangle;
        };
        Rectangle.prototype.componentsCreated = function () {
            /* ignore */
        };
        Object.defineProperty(Rectangle.prototype, "propsHandlers", {
            get: function () {
                return [new ContainerPropsHandler(), new ControlPropsHandler(), new RectanglePropsHandler()];
            },
            enumerable: true,
            configurable: true
        });
        return Rectangle;
    }(GUI2DSceneComponent));

    var __extends$m = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * Class used to create texture to support 2D GUI elements
     */
    var AdvancedDynamicTexture = /** @class */ (function (_super) {
        __extends$m(AdvancedDynamicTexture, _super);
        function AdvancedDynamicTexture() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        AdvancedDynamicTexture.prototype.addControl = function (control) {
            this.advancedDynamicTexture.addControl(control);
        };
        AdvancedDynamicTexture.prototype.removeControl = function (control) {
            this.advancedDynamicTexture.removeControl(control);
        };
        AdvancedDynamicTexture.prototype.componentWillReceiveProps = function () {
            // not implemented for StackPanel
        };
        AdvancedDynamicTexture.prototype.create = function (scene) {
            this.advancedDynamicTexture =
                this.props.createForParentMesh === true
                    ? babylonjsGui.AdvancedDynamicTexture.CreateForMesh(this.props.container.babylonObject, this.props.width, this.props.height, this.props.supportPointerMove, this.props.onlyAlphaTesting)
                    : new babylonjsGui.AdvancedDynamicTexture(this.props.name, this.props.width, this.props.height, scene, this.props.generateMipMaps, this.props.samplingMode);
            return this.advancedDynamicTexture;
        };
        AdvancedDynamicTexture.prototype.componentsCreated = function () {
            /* ignore */
        };
        Object.defineProperty(AdvancedDynamicTexture.prototype, "propsHandlers", {
            get: function () {
                return [
                /* TODO: create a texture props handler */
                ];
            },
            enumerable: true,
            configurable: true
        });
        return AdvancedDynamicTexture;
    }(GUI2DSceneComponent));

    var __extends$n = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * 2D Button
     */
    var Button = /** @class */ (function (_super) {
        __extends$n(Button, _super);
        function Button() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Button.prototype.componentsCreated = function () {
            // not used
        };
        Button.prototype.addControl = function (control) {
            this.button.addControl(control);
        };
        Button.prototype.removeControl = function (control) {
            this.button.removeControl(control);
        };
        Button.prototype.create = function (scene) {
            this.button = new babylonjsGui.Button(this.props.name);
            // Missing click/enter/move/out/etc.
            if (typeof this.props.onPointerDown === "function") {
                this.button.onPointerDownObservable.add(this.props.onPointerDown);
            }
            return this.button;
        };
        Object.defineProperty(Button.prototype, "propsHandlers", {
            get: function () {
                return [new ContainerPropsHandler(), new ControlPropsHandler(), new RectanglePropsHandler()];
            },
            enumerable: true,
            configurable: true
        });
        return Button;
    }(GUI2DSceneComponent));

    var __extends$o = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * Cannot be attached directly to a 3D panel.
     */
    var VirtualKeyboard = /** @class */ (function (_super) {
        __extends$o(VirtualKeyboard, _super);
        function VirtualKeyboard() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.keyboardConnected = false;
            return _this;
        }
        VirtualKeyboard.prototype.componentsCreated = function () {
            var _this = this;
            if (this.keyboardConnected === false) {
                this.keyboardConnected = true;
                if (this.props.controlNames) {
                    this.props.controlNames.forEach(function (controlName) {
                        var control = _this.props.componentRegistry.registeredComponents.find(function (control) { return control.name === controlName; });
                        if (control === undefined) {
                            console.log("Virtual Keyboard cannot locate:", controlName);
                        }
                        else {
                            if (control instanceof InputText) {
                                var inputText = control.babylonObject;
                                _this.virtualKeyboard.connect(inputText);
                            }
                            else {
                                console.error("Can only connect to input text..  Not: '" + controlName + "'");
                            }
                        }
                    });
                }
                else {
                    console.warn("Virtual Keyboard has nothing to connect to.  Will always be displayed.");
                }
            }
        };
        VirtualKeyboard.prototype.addControl = function (control) {
            throw new Error("Method not implemented.");
        };
        VirtualKeyboard.prototype.removeControl = function (control) {
            throw new Error("Method not implemented.");
        };
        VirtualKeyboard.prototype.create = function (scene) {
            this.virtualKeyboard = babylonjsGui.VirtualKeyboard.CreateDefaultLayout();
            return this.virtualKeyboard;
        };
        Object.defineProperty(VirtualKeyboard.prototype, "propsHandlers", {
            get: function () {
                return [new ContainerPropsHandler(), new ControlPropsHandler()];
            },
            enumerable: true,
            configurable: true
        });
        return VirtualKeyboard;
    }(GUI2DSceneComponent));

    var __extends$p = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __assign$5 = (undefined && undefined.__assign) || Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    var __rest$5 = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
                t[p[i]] = s[p[i]];
        return t;
    };
    var RotateMeshBehaviour = /** @class */ (function (_super) {
        __extends$p(RotateMeshBehaviour, _super);
        function RotateMeshBehaviour(props) {
            var _this = _super.call(this, props) || this;
            _this.behaviourAdded = false;
            var scene = props.scene, name = props.name, rest = __rest$5(props, ["scene", "name"]);
            _this.options = __assign$5({}, rest);
            return _this;
        }
        // componentWillUnmount() could unregister, but Scene is being destroyed, so not bothering.
        RotateMeshBehaviour.prototype.apply = function (target, scene) {
            var _this = this;
            scene.registerBeforeRender(function () {
                // todo check for rotationQuaternion.
                var _a = _this.props, radians = _a.radians, axis = _a.axis;
                if (typeof axis === "string") {
                    // computed prop fails: target.rotation[prop] += radians;
                    switch (axis) {
                        case "x":
                            target.rotation.x += radians;
                            break;
                        case "y":
                            target.rotation.y += radians;
                            break;
                        case "z":
                            target.rotation.z += radians;
                            break;
                        default:
                            console.error("unidentified axis", axis);
                    }
                }
                else {
                    // TODO: Add as an input, for World.  Probably don't need Bone :)
                    target.rotate(axis, radians, babylonjs.Space.LOCAL);
                }
            });
        };
        RotateMeshBehaviour.prototype.render = function () {
            if (this.behaviourAdded === false) {
                this.behaviourAdded = true;
                if (this.props.addBehavior) {
                    this.props.addBehavior(this);
                }
                else {
                    console.error("cannot attach behaviour", this.props);
                }
            }
            return null;
        };
        return RotateMeshBehaviour;
    }(React.Component));

    var ModelPropsHandler = /** @class */ (function () {
        function ModelPropsHandler() {
        }
        ModelPropsHandler.prototype.handle = function (loadedModel, props) {
            if (props.position && loadedModel.rootMesh && !loadedModel.rootMesh.position.equals(props.position)) {
                loadedModel.rootMesh.position.copyFrom(props.position);
            }
            if (props.showBoundingBox !== undefined &&
                loadedModel.rootMesh &&
                loadedModel.rootMesh.showBoundingBox !== props.showBoundingBox) {
                var boundingInfo = loadedModel.boundingInfo;
                if (boundingInfo) {
                    // should always have a bounding info, once meshes are loaded
                    loadedModel.rootMesh.setBoundingInfo(boundingInfo);
                }
                loadedModel.rootMesh.showBoundingBox = props.showBoundingBox;
            }
            if (props.scaling && loadedModel.rootMesh && !loadedModel.rootMesh.scaling.equals(props.scaling)) {
                loadedModel.rootMesh.scaling.copyFrom(props.scaling);
            }
            if (props.scaleToDimension && loadedModel && loadedModel.scaleToDimension !== props.scaleToDimension) {
                var boundingInfo = loadedModel.boundingInfo; // will be null when no meshes are loaded
                if (boundingInfo) {
                    var longestDimension = Math.max(Math.abs(boundingInfo.minimum.x - boundingInfo.maximum.x), Math.abs(boundingInfo.minimum.y - boundingInfo.maximum.y), Math.abs(boundingInfo.minimum.z - boundingInfo.maximum.z));
                    var dimension = props.scaleToDimension / longestDimension;
                    loadedModel.rootMesh.scaling.scaleInPlace(dimension);
                    loadedModel.scaleToDimension = props.scaleToDimension;
                }
            }
            if (props.rotation && loadedModel.rootMesh && !loadedModel.rootMesh.rotation.equals(props.rotation)) {
                loadedModel.rootMesh.rotation.copyFrom(props.rotation);
            }
        };
        return ModelPropsHandler;
    }());

    var __extends$q = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    (function (LoaderStatus) {
        LoaderStatus[LoaderStatus["Loading"] = 0] = "Loading";
        LoaderStatus[LoaderStatus["Loaded"] = 1] = "Loaded";
        LoaderStatus[LoaderStatus["Error"] = 2] = "Error";
    })(exports.LoaderStatus || (exports.LoaderStatus = {}));
    var LoadedModel = /** @class */ (function () {
        function LoadedModel() {
        }
        Object.defineProperty(LoadedModel.prototype, "boundingInfo", {
            get: function () {
                if (!this.rootMesh) {
                    return null;
                }
                // meshes are already parented to root mesh, so we do not need to look further.
                var min = null;
                var max = null;
                this.rootMesh.getChildMeshes().forEach(function (childMesh) {
                    var _a = childMesh.getBoundingInfo().boundingBox, minimumWorld = _a.minimumWorld, maximumWorld = _a.maximumWorld;
                    if (min === null) {
                        min = minimumWorld;
                    }
                    else {
                        min = babylonjs.Vector3.Minimize(min, minimumWorld);
                    }
                    if (max === null) {
                        max = maximumWorld;
                    }
                    else {
                        max = babylonjs.Vector3.Maximize(max, maximumWorld);
                    }
                });
                if (min !== null && max != null) {
                    return new babylonjs.BoundingInfo(min, max);
                }
                return null;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Clean up all resources.
         */
        LoadedModel.prototype.dispose = function () {
            if (this.meshes) {
                this.meshes.forEach(function (mesh) {
                    mesh.dispose(false /* not recursive */, true /* materials + textures */);
                });
                this.meshes = [];
            }
            if (this.particleSystems) {
                this.particleSystems.forEach(function (ps) {
                    // ps.stop();
                    ps.dispose();
                });
                this.particleSystems = [];
            }
            if (this.skeletons) {
                this.skeletons.forEach(function (skeleton) { return skeleton.dispose(); });
                this.skeletons = [];
            }
            if (this.animationGroups) {
                this.animationGroups.forEach(function (animationGroup) { return animationGroup.dispose(); });
                this.animationGroups = [];
            }
        };
        return LoadedModel;
    }());
    var Model = /** @class */ (function (_super) {
        __extends$q(Model, _super);
        function Model() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Model.prototype.create = function (scene) {
            var _this = this;
            var loadedModel = new LoadedModel();
            loadedModel.status = exports.LoaderStatus.Loading;
            this.loadedModel = loadedModel;
            var loader = babylonjs.SceneLoader.ImportMesh(undefined, this.props.rootUrl, this.props.sceneFilename, scene, function (meshes, particleSystems, skeletons, animationGroups) {
                loadedModel.rootMesh = new babylonjs.AbstractMesh(_this.props.sceneFilename + "-model");
                loadedModel.rootMesh.alwaysSelectAsActiveMesh = true;
                loadedModel.meshes = [];
                meshes.forEach(function (mesh) {
                    loadedModel.meshes.push(mesh);
                    // leave meshes already parented to maintain model hierarchy:
                    if (!mesh.parent) {
                        mesh.parent = loadedModel.rootMesh;
                    }
                    if (_this.props.receiveShadows === true) {
                        mesh.receiveShadows = true;
                    }
                });
                loadedModel.particleSystems = particleSystems;
                loadedModel.skeletons = skeletons;
                loadedModel.animationGroups = animationGroups;
                if (_this.props.onModelLoaded) {
                    _this.props.onModelLoaded(loadedModel);
                }
                loadedModel.status = exports.LoaderStatus.Loaded;
                // this.forceUpdate() trickery OR call handlers manually
                if (typeof _this.propsHandlers !== undefined && Array.isArray(_this.propsHandlers)) {
                    _this.propsHandlers.forEach(function (propsHandlers) {
                        propsHandlers.handle(loadedModel, _this.props);
                    });
                }
            }, function (event) {
                if (_this.props.onLoadProgress) {
                    _this.props.onLoadProgress(event);
                }
            }, function (scene, message, exception) {
                loadedModel.status = exports.LoaderStatus.Error;
                loadedModel.errorMessage = "error: " + message + " -> " + (exception ? exception.message : "no exception");
                if (_this.props.onModelError) {
                    _this.props.onModelError(loadedModel);
                }
            }, this.props.pluginExtension);
            if (loader) {
                loadedModel.loaderName = loader.name;
            }
            else {
                loadedModel.loaderName = "no loader found";
            }
            return loadedModel;
        };
        Model.prototype.componentsCreated = function () {
            /* ignore */
        };
        Model.prototype.componentWillUnmount = function () {
            if (this.loadedModel) {
                this.loadedModel.dispose();
            }
        };
        Object.defineProperty(Model.prototype, "propsHandlers", {
            get: function () {
                return [new ModelPropsHandler()];
            },
            enumerable: true,
            configurable: true
        });
        return Model;
    }(SceneComponent));

    var __extends$r = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __rest$6 = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
                t[p[i]] = s[p[i]];
        return t;
    };
    var Environment = /** @class */ (function (_super) {
        __extends$r(Environment, _super);
        function Environment() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Environment.prototype.componentWillUnmount = function () {
            this.environmentHelper.dispose();
        };
        Object.defineProperty(Environment.prototype, "ground", {
            get: function () {
                return this.environmentHelper ? this.environmentHelper.ground : null;
            },
            enumerable: true,
            configurable: true
        });
        Environment.prototype.componentsCreated = function () {
            /* ignored */
        };
        Environment.prototype.create = function (createdScene) {
            var _a = this.props, scene = _a.scene, container = _a.container, registerChild = _a.registerChild, options = __rest$6(_a, ["scene", "container", "registerChild"]);
            this.environmentHelper = createdScene.createDefaultEnvironment(options);
            // console.log("created environment helper with options:", options)
            if (options.mainColor) {
                this.environmentHelper.setMainColor(options.mainColor);
            }
            return this.environmentHelper;
        };
        Object.defineProperty(Environment.prototype, "propsHandlers", {
            get: function () {
                return [];
            },
            enumerable: true,
            configurable: true
        });
        return Environment;
    }(SceneComponent));

    var __extends$s = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __rest$7 = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
                t[p[i]] = s[p[i]];
        return t;
    };
    var VRExperience = /** @class */ (function (_super) {
        __extends$s(VRExperience, _super);
        function VRExperience() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        VRExperience.prototype.componentWillUnmount = function () {
            if (this.experienceHelper) {
                // clean up resources, but importantly also to remove the button attached to document.body:
                this.experienceHelper.dispose();
            }
        };
        VRExperience.prototype.componentsCreated = function () {
            var _this = this;
            if (this.props.teleportEnvironmentGround !== true && this.props.teleportationMeshes === undefined) {
                console.log("environment not set to teleport.");
            }
            var environmentGround = undefined;
            var registeredComponents = this.props.componentRegistry.registeredComponents.slice(0);
            registeredComponents.forEach(function (registeredComponent) {
                if (registeredComponent instanceof Environment) {
                    if (_this.props.teleportEnvironmentGround !== true) {
                        // console.log("found environment, but not set for teleportation.")
                        return;
                    }
                    if (!registeredComponent.ground) {
                        // console.error("found environment, but no ground to teleport")
                        return;
                    }
                    environmentGround = registeredComponent.ground;
                }
            });
            if (environmentGround !== undefined || this.props.teleportationMeshes !== undefined) {
                var floorMeshes = environmentGround === undefined ? [] : [environmentGround];
                if (this.props.teleportationMeshes !== undefined) {
                    floorMeshes.concat(this.props.teleportationMeshes);
                }
                // console.log("teleportation enabled on:", floorMeshes.slice(0))
                this.experienceHelper.enableTeleportation({ floorMeshes: floorMeshes });
            }
        };
        VRExperience.prototype.create = function (createdScene) {
            var _a = this.props, scene = _a.scene, container = _a.container, registerChild = _a.registerChild, options = __rest$7(_a, ["scene", "container", "registerChild"]);
            this.experienceHelper = new babylonjs.VRExperienceHelper(createdScene, options);
            // console.log("created experience helper.  options:", options)
            if (options.enableInteractions) {
                this.experienceHelper.enableInteractions();
            }
            if (options.raySelectionPredicate) {
                this.experienceHelper.raySelectionPredicate = options.raySelectionPredicate;
            }
            return this.experienceHelper;
        };
        Object.defineProperty(VRExperience.prototype, "propsHandlers", {
            get: function () {
                return [];
            },
            enumerable: true,
            configurable: true
        });
        return VRExperience;
    }(SceneComponent));

    var __extends$t = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var Skybox = /** @class */ (function (_super) {
        __extends$t(Skybox, _super);
        function Skybox() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Skybox.prototype.componentsCreated = function () {
            /* ignored */
        };
        Skybox.prototype.componentDidUpdate = function () {
            if (this.skyboxMaterial && this.props.texture !== this.lastTexture) {
                this.lastTexture = this.props.texture;
                // need to re-assign coordinates mode to keep skybox displaying correctly
                this.skyboxMaterial.reflectionTexture = new babylonjs.CubeTexture(this.props.texture, this.props.scene);
                this.skyboxMaterial.reflectionTexture.coordinatesMode = babylonjs.Texture.SKYBOX_MODE;
            }
        };
        Skybox.prototype.create = function (scene) {
            var skybox = babylonjs.Mesh.CreateBox("skyBox", 100.0, scene);
            this.skybox = skybox;
            var skyboxMaterial = new babylonjs.StandardMaterial("skyBox", scene);
            // assign to local var to recreate cube-textures
            this.skyboxMaterial = skyboxMaterial;
            skyboxMaterial.backFaceCulling = false;
            skyboxMaterial.disableLighting = true;
            skybox.material = skyboxMaterial;
            // Next, we set the infiniteDistance property. This makes the skybox follow our camera's position.
            skybox.infiniteDistance = this.props.infiniteDistance ? this.props.infiniteDistance : true;
            // Now we must remove all light reflections on our box (the sun doesn't reflect on the sky!):
            skyboxMaterial.disableLighting = true;
            // Next, we apply our special sky texture to it. This texture must have been prepared to be a skybox, in a dedicated directory, named “skybox” in our example:
            this.lastTexture = this.props.texture;
            skyboxMaterial.reflectionTexture = new babylonjs.CubeTexture(this.props.texture, scene);
            skyboxMaterial.reflectionTexture.coordinatesMode = babylonjs.Texture.SKYBOX_MODE;
            // Final note, if you want your skybox to render behind everything else, set the skybox's renderingGroupId to 0, and every other renderable
            // object's renderingGroupId greater than zero, for example:
            if (this.props.renderingGroupId) {
                skybox.renderingGroupId = this.props.renderingGroupId;
            }
            return this.skybox;
        };
        Object.defineProperty(Skybox.prototype, "propsHandlers", {
            get: function () {
                return [];
            },
            enumerable: true,
            configurable: true
        });
        return Skybox;
    }(SceneComponent));

    var __extends$u = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __assign$6 = (undefined && undefined.__assign) || Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    var __rest$8 = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
                t[p[i]] = s[p[i]];
        return t;
    };
    var StandardMaterial = /** @class */ (function (_super) {
        __extends$u(StandardMaterial, _super);
        function StandardMaterial(props) {
            var _this = _super.call(this, props) || this;
            _this.materialSet = false;
            var scene = props.scene, name = props.name, rest = __rest$8(props, ["scene", "name"]);
            _this.options = __assign$6({}, rest);
            return _this;
        }
        StandardMaterial.prototype.apply = function (target, scene) {
            var standardMaterial = new babylonjs.StandardMaterial(this.props.name, scene);
            // TODO: need a props listener for changes to props
            if (this.props.ambientColor) {
                standardMaterial.ambientColor = this.props.ambientColor;
            }
            if (this.props.diffuseColor) {
                standardMaterial.diffuseColor = this.props.diffuseColor;
            }
            if (this.props.emmissiveColor) {
                standardMaterial.emissiveColor = this.props.emmissiveColor;
            }
            if (this.props.specularColor) {
                standardMaterial.specularColor = this.props.specularColor;
            }
            target.material = standardMaterial;
        };
        StandardMaterial.prototype.render = function () {
            if (this.materialSet === false) {
                this.materialSet = true;
                if (this.props.setMaterial) {
                    this.props.setMaterial(this);
                }
                else {
                    console.error("cannot attach material", this.props);
                }
            }
            return null;
        };
        return StandardMaterial;
    }(React.Component));

    exports.Scene = Scene;
    exports.HemisphericLight = HemisphericLight;
    exports.DirectionalLight = DirectionalLight;
    exports.ShadowGenerator = ShadowGenerator;
    exports.Box = Box;
    exports.Sphere = Sphere;
    exports.IcoSphere = Box$1;
    exports.Plane = Plane;
    exports.Ground = Ground;
    exports.GUI3DSceneComponent = GUI3DSceneComponent;
    exports.GUI3DManager = GUI3DManager;
    exports.CylinderPanel = CylinderPanel;
    exports.HolographicButton = HolographicButton;
    exports.Button3D = Button3D;
    exports.GUI2DSceneComponent = GUI2DSceneComponent;
    exports.Text = Text;
    exports.InputText = InputText;
    exports.StackPanel = StackPanel;
    exports.Rectangle = Rectangle;
    exports.AdvancedDynamicTexture = AdvancedDynamicTexture;
    exports.Button = Button;
    exports.VirtualKeyboard = VirtualKeyboard;
    exports.FreeCamera = FreeCamera;
    exports.ArcRotateCamera = ArcRotateCamera;
    exports.CameraPropsHandler = CameraPropsHandler;
    exports.RotateMeshBehavior = RotateMeshBehaviour;
    exports.Model = Model;
    exports.LoadedModel = LoadedModel;
    exports.VRExperience = VRExperience;
    exports.Environment = Environment;
    exports.Skybox = Skybox;
    exports.StandardMaterial = StandardMaterial;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
